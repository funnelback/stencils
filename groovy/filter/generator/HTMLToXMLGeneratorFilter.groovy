package com.funnelback.services.filter;

import com.funnelback.common.utils.TextUtils;

import java.text.*
import java.util.Calendar;
import java.util.regex.*;
import java.io.*;
import java.text.*

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.jsoup.nodes.Entities.EscapeMode;

import com.funnelback.common.*
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.Logger;

import groovy.xml.MarkupBuilder;
import groovy.json.JsonSlurper;

/*
  Generates XMLs from a single document based on a css selectors

  e.g. Given a page with a listing of products and product pages are unavailable, this filter can be used to create
  xmls for each product. A search can then be built on each individual products and not just
  the product listing page.

  The following collection.cfg options can be used to configure this filter:
  
  filter.html_xml_generator.xml_header
    Description:    Sets the header definition of the resulting xmls
    Default value:  <?xml version=\"1.0\" encoding=\"UTF-8\"?> \n
  
  filter.html_xml_generator.target_folder
    Description:    The folder to store the generated xmls
    Default value:  $SEARCH_HOME/conf/$COLLECTION_NAME/xml_source/

  filter.html_xml_generator.node_selector
    Description:    CSS selector to determine one xml entry
    Default value:  body     

  filter.html_xml_generator.config_delimiter
    Description:    The delimiter used to separate the name and css selector
    Default value:  |    

  filter.html_xml_generator.data_delimiter
    Description:    The delimiter used to separate the data for each field. 
                    i.e. <p> one </p> <p> two> </p> <p> three>
                    For the css selector p on the above, the resulting field will be 
                    one|two|three
    Default value: |     

  filter.html_xml_generator.entry.x
    Description:    Specifies the name of the element and css selector which is used to create each xml element
    Default value:  N/A

  Some examples can be found below:

  1.  html_xml_generator.node_selector=body
      filter.html_xml_generator.entry.1=description|p

      Will create one xml in the target folder with a xml with a field <description> <contents of p> </description>

  2.  html_xml_generator.node_selector=div.product
      filter.html_xml_generator.entry.1=price|.price
      filter.html_xml_generator.entry.2=description|.description

      Will create <x> number of xml where x is the number of div.products found in the document in the target folder.
      The xmls will have a price and description field based on the selector .price and .description respectively.

ToDo: 
  - Move xmls into their own subdirectory
  - Add url restrictions

*/
@groovy.transform.InheritConstructors
public class HTMLtoXMLGeneratorFilter extends com.funnelback.common.filter.ScriptFilterProvider
{
  private static final Logger logger = Logger.getLogger(HTMLtoXMLGeneratorFilter.class);
  public final static String MINIMAL_HTML = "<html><head></head><body></body></html>";
  public final static String CDATA_START_TAG = "<![CDATA[";
  public final static String CDATA_END_TAG = "]]>";
  public final static String XML_HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n";

  public final static String SOURCE_URL_TAG = "fb_url";
  public final static String SOURCE_ID_TAG = "fb_id";

  public final static String SEARCH_HOME =  Environment.getValidSearchHome();

  public String collectionName;

  public final String XML_HEADER_CONFIG_NAME = "filter.html_xml_generator.xml_header";
  public final String XML_HEADER_DEFAULT = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n";
  public String xmlHeader;

  //The target folder in which to store all the xmls which are generated by this filter
  public final String TARGET_FOLDER_CONFIG_NAME = "filter.html_xml_generator.target_folder";
  public final String TARGET_FOLDER_DEFAULT = SEARCH_HOME + File.separator + "conf" + collectionName + File.separator + "xml_source";
  public String targetFolder;

  // Determines the content for each xml
  public final String NODE_SELECTOR_CONFIG_NAME = "filter.html_xml_generator.node_selector";
  public final String NODE_SELECTOR_CONFIG_DEFAULT = "body";
  public String nodeSelector;

  //The delimiter to use to seperate the name of the xml element and the css selector
  public final String CONFIG_DELIMETER_CONFIG_NAME = "filter.html_xml_generator.config_delimiter";
  public final String CONFIG_DELIMETER_FOLDER_DEFAULT = "|";
  public String configDelimiter;

  //The delimiter to use to seperate the name of the xml element and the css selector
  public final String DATA_DELIMETER_CONFIG_NAME = "filter.html_xml_generator.data_delimiter";
  public final String DATA_DELIMETER_FOLDER_DEFAULT = "|";
  public String dataDelimiter;
  
  public Map configEntries;

  public static int idCounter = 1; 

  //The prefix which all entries must have. i.e. 
  //filter.html_xml_generator.entry.1
  //filter.html_xml_generator.entry.10
  //filter.html_xml_generator.entry.999
  public final String ENTRY_PREFIX = "filter.html_xml_generator.entry";
  
  public final static String HTML_ELEMENT_REGEX = "<[^>]+>"

  //Constructor
  public HTMLtoXMLGeneratorFilter(String collectionName, boolean inlineFiltering)
  {
    super(collectionName, inlineFiltering);

    //Set the collection name
    this.collectionName = collectionName;

    //Read the settings required for the filter
    xmlHeader =  readCollectionConfig(XML_HEADER_CONFIG_NAME, XML_HEADER_DEFAULT );  
    targetFolder =  readCollectionConfig(TARGET_FOLDER_CONFIG_NAME, TARGET_FOLDER_DEFAULT );
    nodeSelector = readCollectionConfig(NODE_SELECTOR_CONFIG_NAME, NODE_SELECTOR_CONFIG_DEFAULT );
    configDelimiter = readCollectionConfig(CONFIG_DELIMETER_CONFIG_NAME, CONFIG_DELIMETER_FOLDER_DEFAULT );
    dataDelimiter = readCollectionConfig(DATA_DELIMETER_CONFIG_NAME, DATA_DELIMETER_FOLDER_DEFAULT );

    //Load all the valid entries
    configEntries = readCollectionConfig(ENTRY_PREFIX);
  }


  // We filter all documents
  public Boolean isDocumentFilterable(String documentType)
  {
    return true;
  }

  /*
    called to filter document
    @input - text which is to be filtered such as html
    @documentType - html, doc, pdf etc
  */
  public String filter(String input, String documentType)
  {
    return filter(input, documentType, getURL(input));
  }

  public String filter(String input, String documentType, String address)
  {
    logger.info("Processing content from URL: '${address}' - With document type of '${documentType}'");

    Document doc;

    try
    {
      //Only run filter for html documents
      //CHANGE: Add URL to ensure that the filter only runs on certain documents
      if(documentType ==~ /\.html|html/)
      {
        doc = getDocument(input, address);
        
        processNodes(doc, nodeSelector, configEntries, address);
        //addMetaData(doc, targetMetaData, subjects);
      }
    }
    catch(Exception e)
    {
      //log the error
      println(e.toString ());
      logger.error(e.toString ());
    }

    //return the filtered html
    if(doc != null)
    {
      return doc.html();
    }
    else
    {
      return input;
    }         
  }

 //Attempts to obtain the value of the @configName found in collection.cfg
 //Defaults to @defaultValue
 public String readCollectionConfig(String configName, String defaultValue )
 {
    String output = "";
    //Setup the URL Config
    try 
    {
      output = config.value(configName);

      if(output == null)
      {
        throw new Exception("No config found for '${configName}'")
      }
    }
    catch(Exception e) 
    {
      output = defaultValue;
      
      println("Unable to find any value for ${configName}. Using default value of '${defaultValue}'");
      logger.info("Unable to find any value for ${configName}. Using default value of '${defaultValue}'");
    }

    return output;
 }

  /**
  * Read the configuration file and store valid lines
  * @param configFile Location of the config file
  * @throws IOException
  */
  private Map readCollectionConfig(String prefix) throws IOException {
    Map<String, String> data = config.getConfigData();
    
    def output = [:];

    data.each()
    {
      key, value ->
        try 
        {
          if(key.startsWith(ENTRY_PREFIX))
          {
            int delimiterLocation =  value.indexOf(configDelimiter);

            if(delimiterLocation > 0)
            {            
              String name = value.substring(0, delimiterLocation);
              String selector = value.substring(delimiterLocation+1)
              
              //Ensure that the selector is valid. Invalid selectors will throw an exception
              validateSelector(selector);
              
              //add the <name>:<value> string pair to the map
              output.put(name,selector);
            }
            else
            {
              logger.warn("Invalid line '${key}:${value}' in configuration file for collection '${collectionName}'");
            }
          }
          
        }
        catch(Exception e) 
        {
          logger.warn("Invalid line '${key}:${value}' in configuration file for collection '${collectionName}'");
          logger.warn(e.toString());
        }        
    }

    return output;
  } 

  //Ensures that the css selector is valid
  public void validateSelector(String input)
  {
    try 
    {
      Document validationDoc = Jsoup.parse(MINIMAL_HTML);
      validationDoc.select(input);
    }
    catch(Exception e) 
    {
      throw new Exception("'${input}' is not a valid selector")
    }
  }

  //Converts a string representation of a html page to a JSOUP Document object
  //Ensures that the character encoding of the document is maintained
  public Document getDocument(String input, String address)
  {
    Document doc;

    //Converts the String into InputStream
    InputStream is = new ByteArrayInputStream(input.getBytes());
    BufferedInputStream bis = new BufferedInputStream(is);
    bis.mark(Integer.MAX_VALUE);
    //Get the character set
    String c = TextUtils.getCharSet(bis);
    bis.reset();
    //Create the JSOUP document object with the calculated character set
    doc = Jsoup.parse(bis, c, address);      
    doc.outputSettings().escapeMode(EscapeMode.xhtml);

    return doc;
  }

  /*
    Created by Alwyn I think to obtain the URL if it is not available via the standard
    Filter() function.
  */
  public String getURL(String input)
  {
    def matched = "";
    // Check for WARC style URL output
    def matcher = (input =~ /(?im)^\+\s+(http.+)$/);
    if (matcher.find())
    {
      matched = matcher[0][1];
      matched = matched.trim();
    }
    else
    {
      // If not matched, check for MirrorStore style URL output
      matcher = (input =~ /<BASE HREF="(http.+)">/);
      if (matcher.find())
      {
        matched = matcher[0][1];
        matched = matched.trim();
      }
    }

    return matched;
  }

  //Process all the nodes in order to produce a map containing the data:value combinations
  //i.e. { "name":"john", "age":"16" }
  public void processNodes(Document doc, String nodeSelector, Map configEntries, String address)
  {
    Elements nodes = doc.select(nodeSelector);

    nodes.each()
    {
      node ->
        Map result = processNode(node, configEntries, address);
        outputXML(result, targetFolder);
    }
  }

  //Processes a node to produce a map containing name:value pairs
  //Name is the first element of the config entries
  //Value is the result of running the selector of the config entries over the node
  public Map processNode(Element node, Map configEntries, String address)
  {
    Map output = [:];

    //Add a reference back to the source URL
    output.put(SOURCE_URL_TAG, address);
    output.put(SOURCE_ID_TAG, idCounter++);

    configEntries.each()
    {
      name, selector ->      
        String extractedData = CDATA_START_TAG;
        boolean flag = false;
        //Get all matching elements from the node and append it to a string
        node.select(selector).eachWithIndex()
        {
          element, index ->
            String currentValue = cleanseHTMLElements(element.html());
            if(currentValue.size() > 0)
            {
              if(flag == false)
              {
                extractedData = extractedData + currentValue;                      
              }
              else
              {
                extractedData = extractedData + dataDelimiter + currentValue;              
              }
            }
        }

        extractedData = extractedData + CDATA_END_TAG;

        //Add the data to the output map
        output.put(name, extractedData);  
    }

    return output;
  }

  //Remove all html elements (<a> </p> <strong> etc.) from @input
  public String cleanseHTMLElements(String input)
  {
    return input.replaceAll(/${HTML_ELEMENT_REGEX}/, "");
  }

  //writes the xml to the specified file. The file parameter must contain the full
  //path and filename.
  public void outputXML(Map input, String location)
  {
    //create a new file object for the xml
    File objNewFile = new File(generateFullFilePath(input, location));

    //ensure that the directory exists
    File objParentDirectory = objNewFile.getParentFile();

    if(!objParentDirectory.exists())
    {
       objParentDirectory.mkdirs();
    }

    //Convert the map to an XML equivalent so that it can be written to file
    String output = convertMaptoXML(input);

    PrintWriter objPW;

    try
    {
      //open a print writer stream to write the contents of the xml to file in utf8 format
      objPW = new PrintWriter(new OutputStreamWriter(new FileOutputStream(objNewFile),"UTF8"));

      objPW.print(output);

      //commit the changes to disk and close the file
      objPW.flush();
    }
    catch(Exception e)
    {
      //rethrow the exception
      throw e;
    }
    finally
    {
      //ensure that we always close the file
      if (objPW != null)
      {
        objPW.close();
      }
    }
  }

  //Generates the absolute path for a file given the @input and @folder
  public String generateFullFilePath(Map input, String folder)
  {
    return folder + generateFileName(input);
  }

  //Generates a unique filename give the @input
  public String generateFileName(Map input)
  {
    return input[SOURCE_ID_TAG].toString().padLeft(6,"0") + ".xml";
  }

  //Converts a map to the XML equivalent 
  public String convertMaptoXML(Map input)
  {
    StringWriter sw = new StringWriter()
      new groovy.xml.MarkupBuilder(sw).with 
      {
        def doubleQuotes = true;
        def visitor = { k, v ->
          "${k}" { v instanceof Map ? v.collect(visitor) : mkp.yieldUnescaped(v) }
          }
        record() { input.collect visitor }
      }

    return xmlHeader + sw.toString();    
  }  

  // A main method to allow very basic testing
  public static void main(String[] args)
  {
    def f = new HTMLtoXMLGeneratorFilter("demo-supercheap-auto-web", true).filter(new File("C:/Users/gioan/Desktop/test.html").getText(), ".html", "www.hin.com.au/news-and-events");

    /* Write out results UTF-8 mode */
    PrintWriter objPW;
    try
    {                    
      File extMDFile = new File('C:/Users/gioan/Desktop/results.html');
      //open a print writer stream to write the contents of the xml to file in utf8 format
      objPW = new PrintWriter(new OutputStreamWriter(new FileOutputStream(extMDFile),"UTF8"));
      objPW.print(f);

      //commit the changes to disk and close the file
      objPW.flush();
    }
    catch(Exception e)
    {
       println e.toString();
    }
    finally
    {
      //ensure that we always close the file
      if (objPW != null)
      {
        objPW.close();
      }
    }
  }
}

